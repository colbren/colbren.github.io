---
layout: essay
type: essay
title: "Reflection on Effort Estimation and Tracking"
date: 2025-12-13
published: True
labels:
  - Reflection
  - Effort Estimation
  - Final Project
---

## How I Made My Effort Estimates
I made my initial effort estimates by breaking each issue into major subtasks such as UI implementation, backend integration, debugging, and testing. For example, when estimating work related to adding map functionality or improving the game page UI, I considered the number of components involved, the need to integrate third-party libraries (such as mapping APIs), and the expected debugging effort. My estimates were largely based on prior coursework experience with similar frontend and full-stack tasks rather than formal historical data. When similar features had already been implemented elsewhere in the project, I used those as informal reference points to approximate time requirements.

## Benefits of Estimating in Advance
Although many estimates were inaccurate, estimating in advance still provided value. It forced me to think through implementation details before writing code, which reduced uncertainty and helped identify risks early. For example, estimating time for map integration made it clear that unfamiliar APIs and asynchronous data handling would be major cost drivers. Originally our plan was to use google maps API, but it was not free, so we instead researched new interactive maps and landed on Leaflet. Even when tasks took longer than expected, having an estimate helped prioritize work and communicate expected progress to the team. Estimation also made scope creep more visible when a task began exceeding its original assumptions.

## Usefulness of Tracking Actual Effort
Tracking actual effort was useful for understanding where my time was truly going. In several cases, I found that non-coding effort such as debugging, researching documentation, and resolving integration issues took as much or more time than writing code itself. This insight helped recalibrate later estimates to include sufficient buffer for investigation and testing. It also influenced project decisions, such as simplifying UI changes rather than pursuing more complex redesigns when time constraints became clear.

## How I Tracked Actual Effort
I tracked my effort manually by noting start and stop times for each work session and categorizing the time as coding or non-coding effort. This was done using a combination of a personal notes document and commit timestamps in Git to cross-check activity. While this approach was not perfectly precise, I believe it captured the overall distribution of effort reasonably well. Short context switches and small interruptions were sometimes missed, so the recorded times should be considered approximations rather than exact measurements.

## Reflection and Future Improvements
If I were to repeat this process, I would improve both estimation and tracking by breaking tasks into smaller, more measurable subtasks and recording time at a finer granularity. I would also explicitly include time for debugging, refactoring, and learning new libraries in initial estimates, as these were consistently underestimated. Using a lightweight time-tracking tool rather than manual notes would likely improve accuracy and reduce reliance on memory.

## AI Use in Effort Estimation and Tracking
I used ChatGPT as a support tool for effort estimation and reflection.
